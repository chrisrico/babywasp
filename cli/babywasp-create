#!/usr/bin/env node
var fs = require('fs');
var async = require('async');
var bip39 = require('bip39');
var prompt = require('prompt');

var common = require('../common.js');

var schema = {
	properties: {
		walletName: {option: '-w, --wallet <name>', description: 'Name of the wallet', required: true},
		copayerName: {option: '-c, --copayer <name>', description: 'Name of this copayer', default: 'BATM Server', required: true},
		m: {option: '-m <num>', description: 'Number of signatures required (1-4)', pattern: /^[1234]$/, required: true},
		n: {option: '-n <num>', description: 'Total number of copayers (1-6)', pattern: /^[123456]$/, required: true},
		network: {option: '-t, --network', description: 'Which network to use (livenet/testnet)', pattern: /^(livenet|testnet)$/, default: 'livenet', required: true}
	}
};

var walletFile;
var program = common.program(schema.properties)
	.option('-f, --force', 'Force creation of a new wallet if one exists')
	.arguments('<wallet-file>')
	.action(function (_walletFile) {
		walletFile = _walletFile;
	})
	.parse(process.argv);

if (!walletFile) program.help();

prompt.override = {
	walletName: program.wallet,
	copayerName: program.copayer,
	m: program.M,
	n: program.N,
	network: program.network
};

async.waterfall([
	checkForWallet,
	getClientDoPrompt,
	createWallet,
	common.saveWalletCallback(walletFile)
], function (err) {
	if (err) console.log('[error] %s', err);
});

function getClientDoPrompt(next) {
	prompt.start();
	async.series({
		client: async.apply(common.getClient, null, program.host, program.verbose),
		prompt: async.apply(prompt.get, schema)
	}, function (err, results) {
		if (err) return next(err);
		return next(null, results.prompt, results.client);
	});
}

function checkForWallet(next) {
	fs.readFile(walletFile, function (err) {
		if (err == null && !program.force) return next('Must use --force to overwrite existing wallet');
		return next(null);
	})
}

function createWallet(p, client, next) {
	client.createWallet(p.walletName, p.copayerName, parseInt(p.m), parseInt(p.n), {network: p.network}, function (err, secret) {
		return next(err, client, secret);
	});
}