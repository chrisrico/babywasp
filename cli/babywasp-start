#!/usr/bin/env node
var async = require('async');
var express = require('express');

var common = require('../common');

var walletFile;
var program = common.program()
	.option('-p, --port <port>', 'Port on which to listen (default: 7000)', 7000, parseInt)
	.option('-f, --fee-level <feeLevel>', 'Priority to use for sent transactions', /^(priority|normal|economy|superEconomy)$/i, 'normal')
	.arguments('<wallet-file>')
	.action(function (_walletFile) {
		walletFile = _walletFile;
	});

program.parse(process.argv);
if (!walletFile) program.help();

function log(level, format) {
	if (level == log.DEBUG && !program.verbose) return;

	var ts = new Date().toISOString().slice(0, 19);

    var args = Array.prototype.slice.call(arguments, 2);
    args.splice(0, 0, '[%s] %s\t' + format, level, ts);
    console.log.apply(console, args);
}
log.info = log.bind(null, 'info');
log.debug = log.bind(null, 'debug');
log.error = log.bind(null, 'error');

async.waterfall([
	async.apply(common.getClient, walletFile, program.host, program.verbose),
	function (client, next) {
		var app = express();
		app.set('x-powered-by', false);

		app.use(function (req, res, next) {
			var ip = req.get('x-real-ip') || req.get('x-forwarded-for') || req.ip;
			log.info('%s\t%s', ip, req.originalUrl);
			next();
		});

		app.get('/balance', getBalance(client));
		app.get('/address', getAddress(client));
		app.post('/send/:address', send(client));

		app.use(function (err, req, res, next) {
			if (res.headersSent) return next(err);
			res.status(500).json(err.hasOwnProperty('message') ? err.message : err);
		});

		app.listen(program.port, function () {
			log.info('Listening on port %s', program.port);
		});
	}
], function (err) {
	if (err) log.error(err);
});

function getBalance(client) {
	return function (req, res, next) {
		client.getBalance({twoStep: true}, function(err, balance) {
			if (err) return next(err);
			res.json(balance.availableAmount);
		});
	}
}

function getAddress(client) {
	var cachedAddress;

	return function (req, res, next) {
		var force = req.query.force == 'true';

		function write(address) {
			if (address) cachedAddress = address.address;
			res.json(cachedAddress);
		}

		function create() {
			client.createAddress({}, function (err, address) {
				if (err) return next(err);
				write(address);
			});
		}

		if (!cachedAddress || force) return create();

		client.getUtxos({addresses: [cachedAddress]}, function (err, utxos) {
			if (err) return next(err);
			if (utxos.length > 0) return create();
			write();
		});
	}
}

function send(client) {
	return function (req, res, next) {
		if (!client.canSign()) return next('Wallet has no private keys');

		var apiKey = req.get('x-api-key');
		var amount = parseInt(req.query.amount);
		if (isNaN(amount)) return next('Invalid parameter value: amount');

		var opts = {
			outputs: [{
				toAddress: req.params.address,
				amount: amount
			}],
			message: req.query.description,
			feeLevel: program.feeLevel
		};

		async.waterfall([
			function (next) {
				common.unlockWallet(client, apiKey, function (err) {
					return next(err, opts);
				});
			},
			client.createTxProposal.bind(client),
			function (txp, next) {
				client.publishTxProposal({txp: txp}, next);
			},
			client.signTxProposal.bind(client),
			client.broadcastTxProposal.bind(client),
			function (tx, next) {
				res.json(tx.txid);
				next();
			}
		], function (err) {
			client.lock();
			return next(err);
		});
	}
}