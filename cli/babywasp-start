#!/usr/bin/env node
var async = require('async');
var express = require('express');

var common = require('../common');

var walletFile;
var program = common.program()
	.option('-p, --port <port>', 'Port on which to listen (default: 7000)', 7000, parseInt)
	.option('-f, --fee-level <feeLevel>', 'Priority to use for sent transactions', /^(priority|normal|economy|superEconomy)$/i, 'normal')
	.arguments('<wallet-file>')
	.action(function (_walletFile) {
		walletFile = _walletFile;
	});

program.parse(process.argv);
if (!walletFile) program.help();

function log(level, format) {
	if (level == log.DEBUG && !program.verbose) return;
    var args = Array.prototype.slice.call(arguments, 2);
    args.splice(0, 0, '[%s] %s\t' + format, level, dateStamp());
    console.log.apply(console, args);
}
log.INFO = 'info';
log.DEBUG = 'debug';
log.ERROR = 'error';

async.waterfall([
	async.apply(common.getClient, walletFile, program.host, program.verbose),
	function (client, next) {
		var app = express();
		app.set('x-powered-by', false);

		app.use(function (req, res, next) {
			log(log.INFO, '%s\t%s', req.ip, req.originalUrl);
			next();
		});

		app.get('/balance', getBalance(client));
		app.get('/address', getAddress(client));
		app.post('/send/:address', send(client));

		app.use(function (err, req, res, next) {
			if (res.headersSent) return next(err);
			res.status(500).json(err.hasOwnProperty('message') ? err.message : err);
		});

		app.listen(program.port, function () {
			log(log.INFO, 'Listening on port %s', program.port);
		});
	}
], function (err) {
	if (err) log(log.ERROR, err);
});

function dateStamp() {
	return new Date().toISOString().slice(0, 19);
}

function getBalance(client) {
	return function (req, res, next) {
		client.getBalance({twoStep: true}, function(err, balance) {
			if (err) return next(err);
			res.json(balance.availableAmount);
		});
	}
}

function getAddress(client) {
	var cachedAddress;

	return function (req, res, next) {
		var force = req.query.force == 'true';

		function write(address) {
			if (address) cachedAddress = address.address;
			res.json(cachedAddress);
		}

		function create() {
			client.createAddress({}, function (err, address) {
				if (err) return next(err);
				write(address);
			});
		}

		if (!cachedAddress || force) return create();

		client.getUtxos({addresses: [cachedAddress]}, function (err, utxos) {
			if (err) return next(err);
			if (utxos.length > 0) return create();
			write();
		});
	}
}

function timer(name) {
	var start = Date.now();
	return function () {
		log(log.DEBUG, '%s\t%d ms', name, Date.now() - start);
	};
}

function send(client) {
	return function (req, res, next) {
		if (!client.canSign()) return next('Wallet has no private keys');

		var apiKey = req.get('x-api-key');
		var amount = parseInt(req.query.amount);
		if (isNaN(amount)) return next('Invalid parameter value: amount');

		var opts = {
			outputs: [{
				toAddress: req.params.address,
				amount: amount
			}],
			message: req.query.description,
			feeLevel: program.feeLevel
		};

		async.waterfall([
			function (next) {
				common.unlockWallet(client, apiKey, function (err) {
					return next(err, opts);
				});
			},
			client.createTxProposal.bind(client),
			function (txp, next) {
				client.publishTxProposal({txp: txp}, next);
			},
			client.signTxProposal.bind(client),
			client.broadcastTxProposal.bind(client),
			function (tx, next) {
				res.json(tx.txid);
				next();
			}
		], function (err) {
			client.lock();
			return next(err);
		});
	}
}