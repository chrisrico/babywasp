#!/usr/bin/env node
var util = require('util');
var async = require('async');
var bitcore = require('bitcore-wallet-client');
var express = require('express');
var request = require('request');

var common = require('../common');

const minFeePerKb = 10000;

var walletFile;
var program = common.program()
	.option('-i, --insight <url>', 'URL of Insight API (default: BlockExplorer)', 'https://blockexplorer.com/api')
	.option('-p, --port <port>', 'Port on which to listen (default: 7000)', 7000)
	.option('-b, --block-target <n>', 'Fee is calculated to include transaction in N blocks', parseInt, 2)
	.option('-f, --default-fee <satoshis>', 'Default fee (in Satoshis) per KB in case calculation fails', parseInt, minFeePerKb)
	.arguments('<wallet-file>')
	.action(function (_walletFile) {
		walletFile = _walletFile;
	});

program.parse(process.argv);
if (!walletFile) program.help();

var feeApiUrl = program.insight + '/utils/estimateFee?nbBlocks=' + program.blockTarget;
var feeEstimate = program.defaultFee;

function getFeeEstimate() {
	request(feeApiUrl, function(err, response, body) {
		if (err || response.statusCode != 200) {
			console.log('[error] %s\tFailed to retrieve fee estimate %s', dateStamp(), err || 'Status code ' + response.statusCode);
			return;
		}

		var fee = Math.floor(JSON.parse(body)[program.blockTarget] * Math.pow(10, 8));
		if (feeEstimate != fee) {
			feeEstimate = fee;
			console.log('[info] %s\tUpdated fee estimate to %s Satoshis/KB', dateStamp(), fee);
		}
	});
	setTimeout(getFeeEstimate, 1000 * 60 * 15).unref();
}

async.waterfall([
	async.apply(common.getClient, walletFile, program.host, program.verbose),
	function (client, next) {
		if (client.canSign()) getFeeEstimate();

		var app = express();
		app.set('x-powered-by', false);

		app.use(function (req, res, next) {
			console.log('[info] %s\t%s\t%s', dateStamp(), req.ip, req.originalUrl);
			next();
		});

		app.get('/balance', getBalance(client));
		app.get('/address', getAddress(client));
		app.post('/send/:address', send(client));

		app.use(function (err, req, res, next) {
			if (res.headersSent) return next(err);
			res.status(500).json(err.hasOwnProperty('message') ? err.message : err);
		});

		app.listen(program.port, function () {
			console.info('[info] %s\tListening on port %s', dateStamp(), program.port);
		});
	}
], function (err) {
	if (err) console.error('[error] %s\t%s', dateStamp(), err);
});

function dateStamp() {
	return new Date().toISOString().slice(0, 19);
}

function getBalance(client) {
	return function (req, res, next) {
		client.getBalance({twoStep: true}, function(err, balance) {
			if (err) return next(err);
			res.json(balance.availableAmount);
		});
	}
}

function getAddress(client) {
	var cachedAddress;

	return function (req, res, next) {
		var force = !!req.query.force;

		function write(address) {
			if (address) cachedAddress = address.address;
			res.json(cachedAddress);
		}

		function create() {
			client.createAddress({}, function (err, address) {
				if (err) return next(err);
				write(address);
			});
		}

		if (!cachedAddress || force) return create();

		client.getUtxos({addresses: [cachedAddress]}, function (err, utxos) {
			if (err) return next(err);
			if (utxos.length > 0) return create();
			write();
		});
	}
}

function calculateFee(amount) {
	// don't pay more than 1/20 of the amount per KB
	// don't pay less than 10000 satoshis per KB
	return Math.max(Math.min(feeEstimate, Math.floor(amount/20)), minFeePerKb);
}

function send(client) {
	return function (req, res, next) {
		if (!client.canSign()) return next('Wallet has no private keys');

		var apiKey = req.get('x-api-key');
		var amount = parseInt(req.query.amount);
		if (isNaN(amount)) return next('Invalid parameter value: amount');

		var opts = {
			toAddress: req.params.address,
			amount: amount,
			message: req.query.description,
			feePerKb: calculateFee(amount)
		};

		async.waterfall([
			async.constant(apiKey),
			unlock(client),
			function (next) {
				client.sendTxProposal(opts, next);
			},
			function (txp, next) {
				client.signTxProposal(txp, next);
			},
			function (txp, next) {
				client.broadcastTxProposal(txp, next);
			},
			function (tx, next) {
				res.json(tx.txid);
			}
		], lock);
	}
}

function lock(client, next) {
	return function (err) {
		client.lock();
		return next(err);
	};
}

function unlock(client) {
	return function (apiKey, next) {
		common.unlockWallet(client, apiKey, function (err) {
			return next(err);
		});
	};
}