#!/usr/bin/env node
var async = require('async');
var express = require('express');
var bodyParser = require('body-parser');

var common = require('../common');

var walletFile;
var program = common.program()
	.option('-p, --port <port>', 'Port on which to listen (default: 7000)', 7000, parseInt)
	.option('-f, --fee-level <feeLevel>', 'Priority to use for sent transactions', /^(priority|normal|economy|superEconomy)$/i, 'normal')
	.arguments('<wallet-file>')
	.action(function (_walletFile) {
		walletFile = _walletFile;
	});

program.parse(process.argv);
if (!walletFile) program.help();

function log(level, format) {
	if (level == log.DEBUG && !program.verbose) return;

	var ts = new Date().toISOString().slice(0, 19);

    var args = Array.prototype.slice.call(arguments, 2);
    args.splice(0, 0, '[%s] %s\t' + format, level, ts);
    console.log.apply(console, args);
}
log.info = log.bind(null, 'info');
log.debug = log.bind(null, 'debug');
log.error = log.bind(null, 'error');

async.waterfall([
	async.apply(common.getClient, walletFile, program.host, program.verbose),
	function (client, next) {
		var app = express();

		app.use(function (req, res, next) {
			var ip = req.get('x-real-ip') || req.get('x-forwarded-for') || req.ip;
			log.info('%s\t%s %s', ip, req.method, req.originalUrl);
			next();
		});

		app.get('/address', getAddress(client, function (addresses) {
			return addresses[0].address;
		}));
		app.get('/balance', getBalance(client));
		app.post('/send/:address', send(client, function (req) {
			return {
				apiKey: req.get('x-api-key'),
				outputs: [{
					toAddress: req.params.address,
					amount: parseInt(req.query.amount)
				}],
				message: req.query.message
			};
		}));

		// bitcoind compatibility
		app.post('/', bodyParser.json(), jsonrpc(client));

		app.use(function (err, req, res, next) {
			if (res.headersSent) return next(err);
			log.error(err);
			res.sendStatus(500);
		});

		app.set('x-powered-by', false);
		app.listen(program.port, function () {
			log.info('Listening on port %s', program.port);
		});
	}
], function (err) {
	if (err) log.error(err);
});

function jsonrpc(client) {
	var _getAddress = getAddress(client, function (addresses) {
		return addresses.map(function(addr) { return addr.address; });
	});
	var _getBalance = getBalance(client);
	var _send = send(client, function (req) {
		var auth = req.get('authorization').split(' ')[1];
		var userPass = new Buffer(auth, 'base64').toString().split(':');
		return {
			apiKey: userPass[1],
			outputs: [{
				toAddress: req.body.params[1],
				amount: req.body.params[2] * Math.pow(10, 8)
			}],
			message: req.body.params[4]
		};
	});

	return function (req, res, next) {
		switch (req.body.method) {
			case 'getaddressesbyaccount':
				return _getAddress(req, res, next);
			case 'getbalance':
				return _getBalance(req, res, next);
			case 'sendfrom':
				return _send(req, res, next);
		}
		next();
	};
}

function getAddress(client, format) {
	return function (req, res, next) {
		client.getMainAddresses({limit: 1, reverse: true}, function (err, addresses) {
			if (err) return next(err);
			res.json(format(addresses));
		})
	}
}

function getBalance(client) {
	return function (req, res, next) {
		client.getBalance({}, function(err, balance) {
			if (err) return next(err);
			res.json(balance.availableAmount);
		});
	}
}

function send(client, getOpts) {
	return function (req, res, next) {
		if (!client.canSign()) return next('Wallet has no private keys');

		var opts = getOpts(req);
		opts.feeLevel = program.feeLevel;

		if (!client.checkPassword(opts.apiKey)) return next('Invalid API key');

		async.waterfall([
			client.createTxProposal.bind(client, getOpts(req)),
			function (txp, next) {
				client.publishTxProposal({txp: txp}, next);
			},
			function (txp, next) {
				client.signTxProposal(txp, opts.apiKey, next);
			},
			client.broadcastTxProposal.bind(client),
			function (tx, next) {
				res.json(tx.txid);
				next();
			}
		], function (err) {
			return next(err);
		});
	}
}