#!/usr/bin/env node
var util = require('util');
var async = require('async');
var bitcore = require('bitcore-wallet-client');
var express = require('express');
var request = require('request');

var common = require('../common');

var feeApiUrl = 'https://bitcoinfees.21.co/api/v1/fees/recommended';

var walletFile;
var program = common.program()
	.option('-p, --port <port>', 'Port on which to listen (default: 7000)', 7000)
	.option('-f, --fee-policy <policy>', 'Determines average confirmation time (economy/normal/priority)', /^(economy|normal|priority)$/i, 'normal')
	.option('-F, --default-fee <fee>', 'Default fee (Satoshis/KB) if unable to calculate', 10000)
	.arguments('<wallet-file>')
	.action(function (_walletFile) {
		walletFile = _walletFile;
	});

program.parse(process.argv);
if (!walletFile) program.help();

var cachedFee = program.defaultFee;
var feeNameMap = { economy: 'hourFee', normal: 'halfHourFee', priority: 'fastestFee' };

function calculateFee() {
	request(feeApiUrl, function(err, response, body) {
		if (err || response.statusCode != 200) return;

		// convert from Satoshis/B to Satoshi/KB
		var fee = JSON.parse(body)[feeNameMap[program.feePolicy]] * 1000;
		if (cachedFee != fee) {
			cachedFee = fee;
			console.log('[info] %s\tNew fee for %s policy: %s Satoshis/KB', dateStamp(), program.feePolicy, fee);
		}
	});
	setTimeout(calculateFee, 1000 * 60 * 15).unref();
}

async.waterfall([
	async.apply(common.getClient, walletFile, program.host, program.verbose),
	function (client, next) {
		var app = express();
		app.set('x-powered-by', false);

		app.use(function (req, res, next) {
			console.log('[info] %s\t%s\t%s', dateStamp(), req.ip, req.originalUrl);
			next();
		});

		app.get('/balance', getBalance(client));
		app.get('/address', getAddress(client));
		app.post('/send/:address', send(client));

		app.use(function (err, req, res, next) {
			if (res.headersSent) return next(err);
			res.status(500).json(err.hasOwnProperty('message') ? err.message : err);
		});

		app.listen(program.port, function () {
			console.info('[info] %s\tListening on port %s', dateStamp(), program.port);
		});
	}
], function (err) {
	if (err) console.error('[error] %s\t%s', dateStamp(), err);
});

calculateFee();

function dateStamp() {
	return new Date().toISOString().slice(0, 19);
}

function getBalance(client) {
	return function (req, res, next) {
		client.getBalance({}, function (err, balance) {
			if (err) return next(err);
			res.json(balance.availableAmount);
		});
	}
}

function getAddress(client) {
	var cachedAddress;

	return function (req, res, next) {
		var force = !!req.query.force;

		function write(address) {
			if (address) cachedAddress = address.address;
			res.json(cachedAddress);
		}

		function create() {
			client.createAddress({}, function (err, address) {
				if (err) return next(err);
				write(address);
			});
		}

		if (!cachedAddress || force) return create();

		client.getUtxos({addresses: [cachedAddress]}, function (err, utxos) {
			if (err) return next(err);
			if (utxos.length > 0) return create();
			write();
		});
	}
}

function send(client) {
	return function (req, res, next) {
		if (!client.canSign()) return next('Wallet has no private keys');

		var apiKey = req.get('x-api-key');
		var opts = {
			toAddress: req.params.address,
			amount: parseInt(req.query.amount),
			message: req.query.description,
			feePerKb: cachedFee
		};
		if (isNaN(opts.amount)) return next('Invalid parameter: amount');

		async.waterfall([
			async.constant(apiKey),
			unlock(client),
			function (next) {
				client.sendTxProposal(opts, next);
			},
			function (txp, next) {
				client.signTxProposal(txp, next);
			},
			function (txp, next) {
				client.broadcastTxProposal(txp, next);
			},
			function (tx, next) {
				res.json(tx.txid);
			}
		], lock);
	}
}

function lock(client, next) {
	return function (err) {
		client.lock();
		return next(err);
	};
}

function unlock(client) {
	return function (apiKey, next) {
		common.unlockWallet(client, apiKey, function (err) {
			return next(err);
		});
	};
}