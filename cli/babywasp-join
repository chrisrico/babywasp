#!/usr/bin/env node
var fs = require('fs');
var async = require('async');
var prompt = require('prompt');

var common = require('../common.js');

var schema = {
	properties: {
		copayerName: {option: '-c, --copayer <name>', description: 'Name of this copayer', default: 'BATM Server', required: true},
		secret: {option: '-i, --invitation', description: 'Wallet invitation from Copay', required: true},
		language: {option: '-l --language', description: 'Which BIP39 word list to use (en/fr/it/ja/es/zh)', pattern: /^(en|fr|it|ja|es|zh)$/, default: 'en'}
	}
};

var walletFile;
var program = common.program(schema.properties)
	.option('-f, --force', 'Force creation of a new wallet if one exists')
	.arguments('<wallet-file>')
	.action(function (_walletFile) {
		walletFile = _walletFile;
	})
	.parse(process.argv);

if (!walletFile) program.help();

prompt.override = {
	copayerName: program.copayer,
	secret: program.secret,
	language: program.language
};

async.waterfall([
	checkForWallet,
	getClientDoPrompt,
	joinWallet,
	common.encryptWallet(walletFile)
], function (err) {
	if (err) console.log('[error] %s', err);
});

function checkForWallet(next) {
	fs.readFile(walletFile, function (err) {
		if (err == null && !program.force) return next('Must use --force to overwrite existing wallet');
		return next();
	})
}

function getClientDoPrompt(next) {
	prompt.start();
	async.series([
		async.apply(prompt.get, schema),
		async.apply(common.getClient, null, program.host, program.verbose)
	], function (err, results) {
		next(err, results[0], results[1]);
	});
}

function joinWallet(p, client, next) {
	client.seedFromRandomWithMnemonic({network: getNetwork(p.secret), language: p.language});

	var mnemonic = client.getMnemonic().split(' ');
	console.log('\n IMPORTANT:\n');
	console.log(' This is your wallet mnemonic. You need it to restore from backup.\n');
	console.log(mnemonic.slice(0, 6).join(' '));
	console.log(mnemonic.slice(6, 12).join(' ') + '\n');
	client.clearMnemonic();

	client.joinWallet(p.secret, p.copayerName, function (err, wallet) {
		return next(err, client);
	});
}

function getNetwork(secret) {
	function split(str, indexes) {
		var parts = [];
		indexes.push(str.length);
		var i = 0;
		while (i < indexes.length) {
			parts.push(str.substring(i == 0 ? 0 : indexes[i - 1], indexes[i]));
			i++;
		};
		return parts;
	};

	var secretSplit = split(secret, [22, 74]);
	return secretSplit[2] == 'T' ? 'testnet' : 'livenet';
}